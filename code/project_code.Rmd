---
title: "Final Project Code"
author: "Samuel Leung"
output: pdf_document
date: "`r Sys.Date()`"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Load Libraries}
source("lp_optimize.R")
```

```{r Project setup with rocket example}
n <- 3
realizations <- 0:n/n
prior_probabilities <- realizations * (1-realizations)

posterior_calc <- function(prior, realizations, successes = 1, n_obs = 1) {
  joint <- prior * dbinom(x = successes, size = n_obs, p = realizations)
  return(joint / sum(joint))
}

posteriors <- posterior_calc(prior = prior_probabilities,
                             realizations = realizations)
```

```{r distance functions}
absolute_dist <- function(from, to) return(abs(to - from))
```


```{r Putting it all together}
# function to sample posterior + indexes for rocket example. Start index at 
# 2, as index 1 is where the posterior = 0
rocket_sampling <- function(indices, n_successes, n_obs, dist, curr_index = 2 , n_iter = 10) {
  ret.indices = rep(NA, n_iter)
  
  realizations = 0:indices / indices
  prior.probabilities = realizations * (1-realizations)
  joint = prior.probabilities * 
    dbinom(x = n_successes, size = n_obs, p = realizations)
  posteriors = joint / sum(joint)

  
  for (i in 1:n_iter) {
    next.index = next_index(curr_index = curr_index, 
                            posteriors = posteriors, 
                            dist = dist)
    ret.indices[i] = next.index
    curr_index = next.index
    
    # perfrom gibbs sampler under new curr_index
    # what the heck is p(j|i) though??
    
    
    
    # update observations. Not sure if this is what i'm supposed to do. 
    # outcome = rbinom(1,1,realizations[curr_index])
    # n_obs = n_obs + 1
    # n_successes = n_successes + outcome
    # ret.samples[i] = rbinom(1,1,)
  }
  return(ret.indices)
}

rocket_sampling(5, 1, 1, curr_index = 3, absolute_dist, n_iter = 10)
```

```{r debug time}
# check constraint matrix
con.mat = constraint_matrix(posteriors = posteriors)

# check objective function
obj.mat = objective_matrix(posteriors = posteriors, 
                           dist = absolute_dist)

# check right-hand side of linear system to solve
# print(con.mat)
# print(c(posteriors, rep(1, dim(con.mat)[[1]]/2)))

sol = lp_optimize(posteriors = posteriors, dist = absolute_dist)
sol.mat = get_solution_matrix(sol, length(posteriors))

# check that global balance holds
# exact inequality kind of whack due to underflow; so we check
# for the values to be within an error bound
epsilon = 1e-10
print(posteriors - tcrossprod(posteriors, sol.mat) < epsilon)

# check that tcrossprod(posteriors, sol.mat) has valid probs.
print(sum(tcrossprod(posteriors, sol.mat)))
```







