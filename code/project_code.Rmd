---
title: "Final Project Code"
author: "Samuel Leung"
output: pdf_document
date: "`r Sys.Date()`"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Load Libraries}
library("coda")
source("lp_optimize.R")
source("test.R")
source("mh_random_walk.R")
```

```{r Project setup with rocket example}
n <- 20
realizations <- 0:n/n
prior_probabilities <- realizations * (1-realizations)

posterior_calc <- function(prior, realizations, successes = 1, n_obs = 1) {
  joint <- prior * dbinom(x = successes, size = n_obs, p = realizations)
  return(joint / sum(joint))
}

posteriors <- posterior_calc(prior = prior_probabilities,
                             realizations = realizations)
```

```{r distance functions}
absolute_dist <- function(from, to) return(abs(to - from))
squared_dist <- function(from, to) return((to-from)**2)
cubed_dist <- function(from, to) return(abs((to-from)**3))
```


```{r Rocket Example Sampling}
# function to sample posterior + indexes for rocket example. Start index at 
# 2, as index 1 is where the posterior = 0
rocket_sampling <- function(indices, n_successes, n_obs, dist, curr.index = 2 , n_iter = 3000) {
  ret.indices = rep(NA, n_iter)
  
  realizations = 0:indices / indices
  prior.probabilities = realizations * (1-realizations)
  joint = prior.probabilities * 
    dbinom(x = n_successes, size = n_obs, p = realizations)
  posteriors = joint / sum(joint)
  sol = lp_optimize(posteriors=posteriors, dist=dist)
  sol.mat = get_solution_matrix(sol, length(posteriors))
  if (!check_all(posteriors, sol.mat, absolute_dist)) {
    stop("Solution does not pass all checks!!")
  }

  for (i in 1:n_iter) {
    target.dist = sol.mat[curr.index,]
    next.index = sample(1:length(target.dist), size=1, prob = target.dist)
    ret.indices[i] = next.index
    curr.index = next.index
  }
  return(ret.indices)
}

rocket_samples = rocket_sampling(20, 3, 3, dist = absolute_dist)
print("Rocket Sampling done!")
```

```{r Sampling for other techniques}
n_iters = 3000
random_walk_samples = mh_sampling(initial_point = 2, n_iters = n_iters)
simple_samples = rep(NA, n_iters)
for (i in 1:n_iters) simple_samples[i] = sample(0:n, size = 1, prob = posteriors)
print("Done random walk and straight sampling!")
```


```{r plot trace, fig.width = 10}
plot_traces_and_hist = function(samples) {
  layout_mat <- matrix(c(1, 2), nrow = 1, ncol = 2,
                       byrow = TRUE)
  layout(mat = layout_mat,
         heights = c(1),
         widths = c(3, 1), respect =TRUE)
  par(mar = c(2,2,0,0))
  plot(samples, axes = TRUE, type = "o", 
       col = rgb(red = 0, green = 0, blue = 0, alpha = 0.2))
  xhist <- hist(samples, plot = FALSE)
  barplot(xhist$counts, axes = TRUE, space = 0, horiz=TRUE)
}
plot_traces_and_hist(rocket_samples)
plot_traces_and_hist(random_walk_samples)
plot_traces_and_hist(simple_samples)
```

```{r Rocket Sampling with squared distances}
squared_rocket_samples = rocket_sampling(20, 3, 3, dist = squared_dist)
plot_traces_and_hist(squared_rocket_samples)
cubed_rocket_samples = rocket_sampling(20, 3, 3, dist = cubed_dist)
plot_traces_and_hist(cubed_rocket_samples)
```

```{r ESS of samples}
effectiveSize(rocket_samples)
effectiveSize(squared_rocket_samples)
effectiveSize(cubed_rocket_samples)
effectiveSize(random_walk_samples)
effectiveSize(simple_samples)
```




EVERYTHING PAST HERE IS ROUGH WORK

```{r debug time}
# check constraint matrix
con.mat = constraint_matrix(posteriors = posteriors)

# check objective function
obj.mat = objective_matrix(posteriors = posteriors, 
                           dist = absolute_dist)

# check right-hand side of linear system to solve
# print(con.mat)
# print(c(posteriors, rep(1, dim(con.mat)[[1]]/2)))

sol = lp_optimize(posteriors = posteriors, dist = absolute_dist)
sol.mat = get_solution_matrix(sol, length(posteriors))

# check that global balance holds
# exact inequality kind of whack due to underflow; so we check
# for the values to be within an error bound
epsilon = 1e-10
print(posteriors - crossprod(posteriors, sol.mat) < epsilon)

# check that tcrossprod(posteriors, sol.mat) has valid probs.
print(sum(crossprod(posteriors, sol.mat)))
```
```{r other checks}
# check to see if solved solution is better than just generating the kernel 
# from pi-stacking
# ind = length(posteriors)
# as.vector(matrix(rep(posteriors, ind), nrow=ind, byrow = TRUE))

# maximizes objective function
objective_function <- function(posteriors, transition.matrix, dist) {
  ind = length(posteriors)
  dist.mat = matrix(NA, nrow = ind, ncol = ind)
  for (col in 1:ind) {
    for (row in 1:ind) {
      dist.mat[row, col] = dist(row, col)
    }
  }
  return(sum(crossprod(posteriors, dist.mat * transition.matrix)))
}

ind = length(posteriors)
pi.stack = matrix(rep(posteriors, ind), nrow=ind, byrow = TRUE)
objective_function(posteriors, pi.stack, absolute_dist) < 
  objective_function(posteriors, sol.mat, absolute_dist)
```

```{r}
source("test.R")
check_all(posteriors, pi.stack, absolute_dist)
```









